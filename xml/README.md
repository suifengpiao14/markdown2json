# 数据标记语言( Data Markup Language)
数据标记语言设计目的是从文本中提取格式化数据.相比人工提取方式，突出优势为维护成本低，生成的结构化数据准确可靠，从而开辟全新的高效研发模式成为可能
***数据标记语言提取数据的完整流程：***
1. 设计目标格式化数据结构，形成id集合(含id格式化模版)
2. 在文档中查找相关数据，并增加标记
3. 将标记语言转换为json数据
4. 将json数据转为目标格式化数据

***数据标记语言的应用：***
有从文本中提取数据的需求，都可以使用数据标记语言。比如从API markdown文档中提取OpenAPI json文档；在需求文档中标记需求，形成结构化数据方便分组聚合。
***数据标记语言vs手工整理数据：***
数据标记语言主要用于从普通文本中提取结构化数据，目前这种工作主要是人工提取，完整流程为：
1. 设计目标格式化数据结构
2. 书写目标格式化数据模板
3. 在文档中查找相关数据，并复制填充模板

***数据标记语言和人工提取数据比较：***
**劣势：**
1. 设计目标格式化数据结构要复杂些，需要明确定义每个属性的唯一id(或者唯一id格式模板)
2. 将json数据转为目标格式数据比人工复制填充模板复杂很多
3. 增加标记比复制数据心智负担大
4. 额外多出将数据标记语言转换为json数据步骤

好在将"数据标记语言转换为json格式"步骤只需实现一次即可，而具体到某个目标格式化数据时，其"设计目标格式化数据结构"和"将json数据转为目标格式数据"这两项工作也是一次性的。所以在频繁使用某种目标格式化数据时，使用标记语言并不会明显增加工作量
，此时会带来一定**优势**：
1. 能增量式的标记数据，而人工提取往往需要一气呵成，降低工作难度
2. 有利于从不同角度思考问题，而不限于结构化数据角度
3. 当原文修改时，其相关链条也需要同步修改时，改动成本非常低(改动点：1:1关系，无查找改动点任务)，而这种情况对"人工提取方式"就是天灾，改动成本明显上升(首先改动点1:n关系，其次更大的挑战是找到所有改动点，即不多改，也不漏改)
4. 结构化数据的准确性和可靠性非常高，错误率接近于0. 使得结构化数据可以视为基础数据，可基于此数据再次延伸。
4. 可靠和易维护的结构化数据为数据的二次应用提供了原始生成资料，能促使后续更多环节的自动化应用（试想基于人工提取的结构化数据经常有纰漏，那基于这个数据转换的sdk也会经常出现不符合预期的情况，问题重复发生几次后，更多的人放弃自动生成的sdk，转而按需手写sdk）

**综上所述，单次操作，数据标记语言比人工提取复杂，但是当原文存在修改维护、多人合作、准确快速响应、高质量等要求时，标记语言能轻易的完成任务而手工整理却实现不了**

### 数据标记语言语法
数据标记语言的是xml 的扩展，在xml的基础上定义一系列固定标签和属性，常用标签有:Attr,Obj,Set,Ref,Origin. 常用属性有 id, encoding 等.通用约定如下:
1. 标签首字母大写
1. 标签id属性必须定义且在单文件内唯一,支持[0-9a-zA-Z_\-\.\[\]]等字符集,其中".","[]"等符合具有特殊意义，"."连接命名空间，在解析成json 格式数据时，会形成对象嵌套结构，"."分割后的字符串后缀为"[]"的，将在转换为json数据时，形成数组结构
2. id命名采用名称空间(namespace)方式，名称空间支持包含关系,使用"."连接各个层级命名空间(如: 亚洲.中国.广东.深圳.福田区.车公庙地铁站A出口)。对应为json对象结构,名称空间支持后缀"[]",对应为json数组结构
3. 所有数据都为字符串类型(如字符—"美丽",数字—"5.60",布尔真—"true"),具体类型需要设计目标有序数据结构时确定
4. 标签无嵌套关系,数据的从属关系只能通过id命名确定
#### 标签
1. 属性标签Attr. 标记单个属性，如从文本"广东省深圳市福田区"中提取省市区,可标记为 <Attr id="address.provice">广东省</Attr><Attr id="address.city">深圳市</Attr><Attr id="address.area">福田区</Attr>，Attr会剪切原文中开头结尾的空格、换行符等，必备属性：id 其它属性：无。
2. 对象标签Obj. 批量标记属性.当文本本身具有规则时，如从文本"广东省-深圳市-福田区-车公庙地铁站A出口"提取省市区，可标记为<Obj id="address" attrs="provice,city,area" regex="(.+?)-(.+?)-(.+?)-">广东省-深圳市-福田区-车公庙地铁站A出口</Obj>必备属性：id,attrs(属性名集合) 其它属性：regex(正则表达式解析数据,捕捉到的数据按顺序依次赋值给attrs的属性),encoding(解释器,暂时支持language/js脚本、language/tengo脚本、shell、curl调用外部接口解析) fn(执行函数,输入为包含的内容，输出按顺序赋值给attrs中的属性)。
3. 集合标签Set. 批量标记对象，经常标记在二维表格上。如从markdown表格中提取数据，可标记 <Set attrs="privice,city,area,detail" id="address" index="detail">xxx(markdown 表格内容)</Set>必备属性：id,attrs(属性名集合) 其它属性：index(二维数据内部唯一值属性名称，和Set id 以"."拼接后形成全局唯一标识)若为空，默认为attrs的第一个属性值，encoding(解析器,暂时支持markdown/table、sql/ddl、sql/dql、excel、csv、shell、curl、tengo脚本)，fn(执行函数,输入为包含的内容，输出按顺序赋值给attrs中的属性)。
4. 原文标记Origin. 标记原文中的某一部分，当有效范围内重复出现某部分内容时，可以用Origin 标记，方便通过程序完善文档本身.Origin 和Attr 不同之处是Origin会保留原文中开头结尾的空格、换行符
5. 引用标记Ref. 引用外部标记文档或者外部文档的特定标记.必备属性id,file/url（文件/连接地址）其它属性:其它标签的属性。引用特定标记时，在文件/链接地址后增加锚点，锚点ID为需要引用的id值，引用入后用Ref标记的id重写引入的标签id。注意：引用不能循环引用，Ref 仅用于引用数据标记语言文本，sql,excel,csv等文件应该使用Set标记获取数据
6. 注释. 和html注释语法一致，注释中可以包含有效的标签，这些标记可用于提供额外的数据，但是不影响原文显示 
7. 占位符标记{{}}.占位符标记不同于其它标记，主要用于将文档中已经标记的数据应用到文档本身.在减少文档重复输入内容方面非常方便，此外还能保持数据一致性。占位符标记是标记抽取的结构化数据应用于当前文档的一个体现，占位符标记，本质上是go语言的template/text,在特定的应用场景下可以增加自定义函数(如接口文档，生成curl案例)，其中内置了部分函数:
* Get——获取提取数据的子对象或者属性.示例:
```go
// 获取当前对象下obj.title.application/json.name 数据(返回值为对象、数组或者字符串)如果id中含有特殊字符，则将自特殊字符开始到后续的id值以字符串形式作为第二个参数
{Get .obj.title ".application/json.name"}}
```
* Strtr——格式化数据输出.示例:
```go
//将.obj.title 对象的指定属性按格式输出,第二个参数为输出格式化，其中.开头的变量表示.obj.title 对象的属性
{Strtr .obj.title ".name|string|是|.description|.default|.example"}}
```
* Ref——引用文本块.实例:
```go
//引用当前文档中id为common.header.application/json.Get 的块内容(实际为common.header.application/json.Get.text),如果id中含有特殊字符，则将自特殊字符开始到后续的id值以字符串形式作为第二个参数
{{Ref .common.header ".application/json.Get"}}
```
